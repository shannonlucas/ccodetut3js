"use strict";(self.webpackChunktutorial=self.webpackChunktutorial||[]).push([[449],{3905:function(e,n,t){t.d(n,{Zo:function(){return h},kt:function(){return p}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},h=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),m=l(t),p=i,u=m["".concat(c,".").concat(p)]||m[p]||d[p]||a;return t?r.createElement(u,o(o({ref:n},h),{},{components:t})):r.createElement(u,o({ref:n},h))}));function p(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=m;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4590:function(e,n,t){t.r(n),t.d(n,{assets:function(){return h},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var r=t(7462),i=t(3366),a=(t(7294),t(3905)),o=["components"],s={id:"checkpoint",title:"Checkpoint",sidebar_position:10,sidebar_label:"Checkpoint"},c=void 0,l={unversionedId:"adding-behavior/checkpoint",id:"adding-behavior/checkpoint",title:"Checkpoint",description:"Content in this section is under development.",source:"@site/docs/adding-behavior/checkpoint.mdx",sourceDirName:"adding-behavior",slug:"/adding-behavior/checkpoint",permalink:"/ccodetut3js/adding-behavior/checkpoint",tags:[],version:"current",sidebarPosition:10,frontMatter:{id:"checkpoint",title:"Checkpoint",sidebar_position:10,sidebar_label:"Checkpoint"},sidebar:"tutorialSidebar",previous:{title:"Postscript",permalink:"/ccodetut3js/adding-behavior/postscript"},next:{title:"Wrapping Up",permalink:"/ccodetut3js/wrapping-up"}},h={},d=[{value:"JavaScript",id:"javascript",level:2},{value:"HTML",id:"html",level:2},{value:"CSS",id:"css",level:2}],m={toc:d};function p(e){var n=e.components,t=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"TO BE DONE")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Content in this section is under development."))),(0,a.kt)("p",null,"Below you will find all the code you've assembled up to this point in the tutorial. Comments have been added to the JavaScript code to reinforce what each section of code does."),(0,a.kt)("p",null,"If you spent some time experimenting, you can copy and paste the code here to return things to where they were when you finished the tutorial."),(0,a.kt)("h2",{id:"javascript"},"JavaScript"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"/* For this tutorial, three.js version 0.137.5 is used. */\nimport * as THREE from 'https://cdn.skypack.dev/three@v0.137.5';\n\n/**\n * Add lights to the given scene.\n * \n * @param {THREE.Scene} scene \n */\nfunction setUpLights(scene) {\n  const light1 = new THREE.PointLight(\"#ea00d9\"); // magenta\n  light1.position.set(8, 3, 4);\n  scene.add(light1);\n\n  const light2 = new THREE.PointLight(\"#0abdc6\"); // cyan\n  light2.position.set(-6, 0, 2);\n  scene.add(light2);\n}\n\n/**\n * Create a perspective camera that looks at the center of the scene.\n * \n * @returns {THREE.Camera}\n */\nfunction setUpCamera() {\n  const aspectRatio = window.innerWidth / window.innerHeight;\n  const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);\n  camera.lookAt(0, 0, 0);\n\n  return camera;\n}\n\n/**\n * Create a renderer and attach it to the HTML canvas element with the provided \n * ID.\n *\n * @param {string} elementId\n * @returns {THREE.WebGLRenderer} the newly created renderer\n */\nfunction setUpRenderer(elementId) {\n  const canvas = document.querySelector(elementId);\n  const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });\n\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n\n  return renderer;\n}\n\n/**\n * Setup the graphics to draw the art to.\n * \n * @param {string} elementId the ID of the HTML <canvas> element to render the\n *        graphics to.\n * @returns {object} an object containing the following properties:\n *                     * renderer - the newly created renderer\n *                     * camera - the newly created camera\n *                     * scene - the newly created scene\n */\nfunction setUpGraphics(elementId) {\n  const renderer = setUpRenderer(elementId);\n  const camera = setUpCamera();\n  const scene = new THREE.Scene();\n  setUpLights(scene);\n\n  // If the browser window gets resized, the camera and renderer have to be\n  // updated. This block of code handles that.\n  window.addEventListener('resize', () => {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  });\n\n  return { renderer, camera, scene };\n}\n\nconst { renderer, camera, scene } = setUpGraphics('#creative-code');\n\n// How many milliseconds to wait between drawing each frame. Divide one second\n// (1000 milliseconds) by the target frame rate of 60 frames per second.\nconst MILLISECONDS_PER_FRAME = 1000 / 60;\n\n// To control the speed of the animation, the time between frames is tracked.\n// This is initially set to zero since no frame has been rendered yet.\nlet lastFrameTime = 0;\n\n/**\n * Animates the scene.\n * \n * This function is called every time computer refreshes its display. The\n * refresh rate will vary from one computer to another and may even vary on the\n * same computer.\n * \n * To make the animation consistent from one computer to another, the function\n * only updates the animation at a set interval.\n * \n * @param {number} animationTime - the amount of time, in milliseconds, since\n *        the animation started.\n */\nfunction animate(animationTime) {\n  const elapsedTime = animationTime - lastFrameTime;\n\n  if (elapsedTime >= MILLISECONDS_PER_FRAME) {\n    update();\n    renderer.render(scene, camera);\n    lastFrameTime = animationTime;\n  }\n}\n\n// Start the animation loop\nrenderer.setAnimationLoop(animate);\n\n/**\n * Creates the 3D model of an individual cell with a given position and size.\n *\n * @param {THREE.Vector3} position the cell's position in 3D space\n * @param {THREE.Vector3} size the cell's size\n * @returns {THREE.Mesh} the 3D mesh to add to the scene\n */\nfunction buildCellMesh(position, size) {\n  const geometry = new THREE.BoxGeometry();\n  const material = new THREE.MeshStandardMaterial({ color: \"#aaa\" });\n  const mesh = new THREE.Mesh(geometry, material);\n\n  mesh.position.copy(position);\n  mesh.scale.copy(size);\n\n  return mesh;\n}\n\n/**\n * Create a square grid of cell meshes.\n *\n * @param {number} gridWidth the width of the grid in cells\n * @param {number} maxCellSize the maximum size of a cell mesh\n * @param {number} spacing how much space to place between each cell mesh\n * @returns {Array<Array<THREE.mesh>>} a nested array of the cell meshes\n */\nfunction buildGridMeshes(gridSize, cellSize, spacing) {\n  const cellWithSpace = cellSize + spacing;\n  const gridCenter = (gridSize * cellWithSpace) / 2;\n  const offset = (cellWithSpace / 2) - gridCenter;\n\n  const meshSize = new THREE.Vector3(cellSize, cellSize, cellSize);\n\n  const cells = [];\n\n  for (let row = 0; row < gridSize; row++) {\n    const y = (row * cellWithSpace) + offset;\n    cells[row] = [];\n\n    for (let column = 0; column < gridSize; column++) {\n      const x = (column * cellWithSpace) + offset;\n      const position = new THREE.Vector3(x, y, 0);\n\n      cells[row][column] = buildCellMesh(position, meshSize);\n    }\n  }\n\n  return cells;\n}\n\n/**\n * Create a group to hold the cell meshes so they can be moved together.\n *\n * @param {Array<Array<object>>} cells the visuals\n * @returns the group containing the cells\n */\n function groupCellMeshes(cells) {\n  const cellGroup = new THREE.Group();\n\n  for (const cell of cells.flat()) {\n    cellGroup.add(cell);\n  }\n\n  // Tilt the group 45 degrees (in radians)\n  cellGroup.rotation.z = Math.PI / 4;\n\n  return cellGroup;\n}\n\n// This is how many rows and columns we'll have in our grid.\nconst GRID_SIZE = 8;\n\n// This is the largest cell size we'll allow.\nconst MAX_CELL_SIZE = 1.0;\n\n// How much space to put between the 3D cubes\nconst CELL_SPACING = MAX_CELL_SIZE / 10;\n\n// Setup our cell visuals and group them together so we can move them all at\n// the same time\nconst cellMeshes = buildGridMeshes(GRID_SIZE, MAX_CELL_SIZE, CELL_SPACING);\nconst cellGroup = groupCellMeshes(cellMeshes);\n\nscene.add(cellGroup);\n\n// Move the camera far enough from our cells that we can see all of them.\ncamera.position.set(0, 0, GRID_SIZE * (MAX_CELL_SIZE + CELL_SPACING));\n\n// The number of radians the grid rotates each frame\nconst ROTATION_SPEED = 0.0075;\n\n/**\n * Create a new cell with a random size and growth direction.\n *\n * @param {number} maxSize the maximum size the cell can grow to; this must be a\n *        positive number\n * @param {number} minSize the minimum size the cell can shrink to; this must be\n *        less than maxSize and greater than or equal to zero\n * @param {number} growthRate how fast the cell can grow each time the next cell\n *        state is generated\n * @returns {object} an object containing the cell information\n */\nfunction spawnCell(maxSize, minSize, growthRate) {\n  const size = Math.random() * (maxSize - minSize) + minSize;\n  const direction = Math.random() < 0.5 ? -1 : 1;\n  const growth = growthRate * direction;\n\n  return {\n    size,\n    growth,\n    maxSize,\n    minSize,\n  };\n}\n\n/**\n * Create an initial square grid of cells.\n *\n * @param {*} gridWidth the width of the grid in cells\n * @param {*} maxSize the maximum size the cell can grow to; this must be a\n *        positive number\n * @param {*} minSize the minimum size the cell can shrink to; this must be\n *        less than maxSize and greater than or equal to zero\n * @param {number} growthRate how fast the cell can grow each time the next cell\n *        state is generated\n * @returns {Array<Array<object>>} a two dimensional array of the cells\n */\nfunction buildBehaviorGrid(gridWidth, maxSize, minSize, growthRate) {\n  let cells = [];\n\n  for (let x = 0; x < gridWidth; x++) {\n    cells[x] = [];\n\n    for (let y = 0; y < gridWidth; y++) {\n      cells[x][y] = spawnCell(maxSize, minSize, growthRate);\n    }\n  }\n\n  return cells;\n}\n\n/**\n * Grow (or shrink) the given cell based on its growth rate.\n *\n * @param {object} currentCell the cell to grow or shrink\n * @returns {object} a new cell object that has grown (or shrank)\n */\nfunction nextCellBehavior(currentCell) {\n  let { size, growth, maxSize, minSize } = currentCell;\n  size = size + growth;\n\n  // Make sure the new size fits within the cell's maximum and minimum\n  if (growth > 0) {\n    size = Math.min(size, maxSize);\n  } else {\n    size = Math.max(size, minSize);\n  }\n\n  // If the new size is at the cell's maximum or minimum size, reverse the\n  // direction of growth.\n  if (size === minSize || size === maxSize) {\n    growth = growth * -1;\n  }\n\n  return {\n    size,\n    growth,\n    maxSize,\n    minSize,\n  };\n}\n\n/**\n * Create a new behavior grid where each cell in the given grid has been\n * resized according to its current growth rate.\n *\n * @param {Array<Array<object>>} currentState\n * @returns {Array<Array<object>>} a two dimensional array of the cells\n */\nfunction nextBehaviorGrid(currentState) {\n  const width = currentState.length;\n  let cells = [];\n\n  for (let x = 0; x < width; x++) {\n    const height = currentState[x].length;\n    cells[x] = [];\n\n    for (let y = 0; y < height; y++) {\n      cells[x][y] = nextCellBehavior(currentState[x][y]);\n    }\n  }\n\n  return cells;\n}\n\n/**\n * Look at the state of each cell and update the 3D visual to match.\n * \n * @param {Array<Array<THREE.object>>} gridState the cell grid of cells to\n *        render\n * @param {Array<Array<THREE.mesh>>} gridView the corresponding grid of 3D \n *        visuals\n */\nfunction applyBehaviorToVisuals(gridState, gridView) {\n  for (let x = 0; x < gridView.length; x++) {\n    for (let y = 0; y < gridView[x].length; y++) {\n      let size = gridState[x][y].size;\n\n      gridView[x][y].scale.set(size, size, size);\n    }\n  }\n}\n\n// This is how fast the cells will grow or shrink.\nconst GROWTH_RATE = 0.015;\n\n// This is the smallest box size we'll allow.\nconst MIN_CELL_SIZE = MAX_CELL_SIZE / 10;\n\n// Create the initial starting state of the cell visuals\nlet state = buildBehaviorGrid(GRID_SIZE, MAX_CELL_SIZE, MIN_CELL_SIZE, GROWTH_RATE);\n\n/**\n * Compute the changes to the cell states and update the meshes to reflect that\n * state.\n */\nfunction update() {\n  applyBehaviorToVisuals(state, cellMeshes);\n  state = nextBehaviorGrid(state);\n  cellGroup.rotation.y += ROTATION_SPEED;\n}\n")),(0,a.kt)("h2",{id:"html"},"HTML"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html lang="en">\n\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" \n          content="width=device-width, minimum-scale=1.0, maximum-scale=1.0">\n    <title>Creative coding with three.js</title>\n    <link rel="stylesheet" type="text/css" href="./style.css" />\n    <script type="module" src="./index.js"><\/script>\n  </head>\n\n  <body>\n    <canvas id="creative-code" class="three"></canvas>\n  </body>\n\n</html>\n')),(0,a.kt)("h2",{id:"css"},"CSS"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"body {\n  background-color: #202;\n  color: #fff;\n  overflow: hidden;\n}\n\n.three {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  position: fixed;\n  width: 100vw;\n  height: 100vh;\n}\n")))}p.isMDXComponent=!0}}]);